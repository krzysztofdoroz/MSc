\chapter{Implemented Algorithms}
\label{cha:implementedAlgorithms}


%---------------------------------------------------------------------------

\section{Trend following}
\label{trend_following_impl}

The crux of the trend following method is to choose a set of entry and exit point conditions that determine our trading strategy.
Simple Moving Average (SMA) is especially useful to highlight longer-term trends in a set of data points.

SMA is formulated as the unweighted mean of the previous $N$ data points:

\begin{equation}
    SMA_{today,N} = \frac{\sum_{i=1}^{N}p_{today - i}}{N}
\end{equation}

\begin{description}
  \item [$p_{j}$] 
    value of data on day $j$
\end{description}


\textbf{Entry points:}
  \begin{itemize}
    \item Simple moving average (SMA) of last $N$ days is greater than SMA of last $M$ days
    \item Current stock price is max of last $N$ days
  \end{itemize}

As soon as at least one of the above conditions is satisfied we go long.


\textbf{Exit points:}
  \begin{itemize}
    \item Losses on a single trade are greater than 2 \% 
    \item Simple moving average (SMA) of last $N$ days is lesser than SMA of last $M$ days
  \end{itemize}

As soon as the exit condition is satisfied we go short.
 
\subsection{Pseudocode}

\begin{description}

\item[SMA(i,N)]
  calculates Simple Moving Average for stock $i$, $N$ last days are taken into account  
\item[go\_short(i)]
  sell stock $i$
\item[go\_long(i)]
  buy stock $i$
\item[get\_current\_stock\_price(i, day)]
  returns stock $i$ price for specific $day$ 
\item[get\_most\_recent\_trade\_price(i)]
  returns the price we paid for stock $i$ (we have stock $i$ in our portfolio)
\item[max(i,N)]
  returns the maximum price for stock $i$ in the last $N$ days
\item[N, M, maximal\_value\_loss]
  parameters 
\end{description}
% 


\begin{algorithmic}

\STATE $maximal\_value\_loss \gets 0.98$

\FOR{$day = 1$ to $max\_day$} 

  \FOR{$i = 1$ to $number\_of\_stocks$}

    \IF {$ get\_most\_recent\_trade\_price(i) < maximal\_value\_loss * get\_current\_stock\_price(i, day) $} 
	    \STATE $go\_short(i)$
    \ELSE
	    \IF {$SMA(i,N) < SMA(i,M)$}
		    \STATE $go\_short(i)$
	    \ENDIF
    \ENDIF

    \IF {$SMA(i,N) > SMA(i,M)$} 
	    \STATE $go\_long(i)$
    \ELSE
	    \IF {$max(i,N)) < get\_current\_stock\_price(i, day)$}
		    \STATE $go\_long(i)$
	    \ENDIF
    \ENDIF

  \ENDFOR

\ENDFOR

\end{algorithmic}


\section{Genetic Algorithm}
\label{sec:genAlgoImpl}

\subsection{Adjusting GA to solve portfolio optimization problem}

As described in \ref{sec:genAlgorithms} each potential solution shoul be encoded in chromosome. 
Each chromosome represents portfolio composition (it is a vector of double values representing percentage share of each stock).

The following modified GA operations have been implemented:
\begin{description}
  \item [mutation]
      Mutation operator changes exactly one value $ \alpha_{i} $ representing percentage share of a specific stock $i$ (each time the value $i$ is chosen randomly)
      to $\alpha_{i}'$ ($\alpha_{i}' \in (0,1)$ is chosen randomly). 
      After that we have to normalize vector.
      $Mutation\_coefficient$ ($mutation\_coefficient \in (0,1)$ ) determines what part of population will be subjected to mutation operator.
  \item [selection]
      $breeding\_coefficient$ ( $breeding\_coefficient \in (0,1)$ ) determines what part of population will be subjected to crossover operator, selection is based on 
      fitness function (only the fittest part of the population will be selected)
  \item [crossover]
      After selection chromosomes eligible for reproduction, each pair of chromosomes are subjected to crossover operator. As a result new chromosomes are created (each pair
      produces two new chromosomes) and added to population. Crossover choose points $left$  and $right$ (both are chosen randomly) which cut parent's chromosomes in the following
      way: 
	  \begin{figure}[!ht]
	    \begin{center}
	      \includegraphics[scale=.4]{parents.png}
	    \end{center}
	    \caption{Example of parent's chromosomes split into 3 parts}
	  \end{figure}

	Now children are created in the following way:    
	  \begin{figure}[!ht]
	    \begin{center}
	      \includegraphics[scale=.4]{children.png}
	    \end{center}
	    \caption{Children's chromosomes contain mixed parent's genetic material}
	  \end{figure}

\end{description}

Apart from that, extinction mechanism has been implemented.
At the end of each GA round a part of the population that has the lowest fitness is exterminated.
$Extinction\_coefficient$ defines what part of population will be subjected to extinction.
 
\subsection{Fitness function}

Fitness is calculated according to the following formula (for portfolio with $N$ stocks):

\begin{equation}
    \gamma_{day} =  \sum_{i=0}^{N} {  \alpha_{i} * \frac{price(i,day)}{price(i,day - 1)} }
\end{equation}

\begin{description}
  \item [$\gamma_{day}$] 
      value of the portfolio's fitness calculated for specific $day$
  \item [$\alpha_{i}$]
      percentage share of a specific stock $i$ in the whole portfolio
  \item [$price(i,day)$]
      returns the price of stock $i$ for a specific $day$
\end{description}

Clearly, the fitness function favours the portfolios which have the highest day-to-day increase in value.
Of course such method of calculating fitness has many drawbacks e.g. it completely omits the aspect of risk associated with investing in highly volatile stocks.
However, it turns out that in spite of this obvious flaw the algorithm is performing quite well.  

\subsection{Class Diagram}

%\clearpage
\begin{figure}[H]   
	    \begin{center}
	      \includegraphics[scale=.35]{Simple_gen_UML.png}
	    \end{center}
	    \caption{Class diagram of GA described in \ref{sec:genAlgoImpl}} 
	  \end{figure}

\begin{description}
  \item [GeneticAlgorithmImpl]
    An implementation of IGeneticAlgorithm, it is responsible for calculating the most optimal portfolio
  \item [GeneticAlgorithmUtils]
    Utility class providing methods used by genetic algorithm (like mutating, crossover etc.)
  \item [IDataSource]
    Described in \ref{dataSource}
  \item [Portfolio]
    Class representing potential solution.

\end{description}

\section{Co-evol}

\subsection{Adjusting co-evol to portfolio optimization problem}

Contrary to \ref{sec:genAlgoImpl} two subpopulations coexist side by side.
Risk oriented subpopulation tries to optimize on risk (the lower risk value the better), whereas the return oriented subpopulation tries to maximize expected return.

Risk as well as expected return are calculated according to Capital Asset Pricing Model described in \ref{CAPM} .



\subsection{Class Diagram}

\begin{figure}[H]   
	    \begin{center}
	      \includegraphics[scale=.38]{co-evol.png}
	    \end{center}
	    \caption{Class diagram of GA described in \ref{sec:genAlgoImpl}} 
	  \end{figure}


%---------------------------------------------------------------------------

\section{Implementation Details}
\label{sec:implDetails}

\subsection{Precomputation of statistical functions}
\label{precompute}
Precomputation of statistical functions (like covariance, standard deviation etc.) from historical data is done by R scripts. 
Results are stored in files, later used as an input to other algorithms.

\subsection{Data Source component}
\label{dataSource}

Data Source component aggregates all stock historical data as well as all precomputed statistical functions results from \ref{precompute}.   
Its interface enables access to all data it contains. Data Source is injected as a bean to other components by Spring.
They use it mainly as a source of data required by various algorithms.

\subsection{Computing Algorithm component}

Computing Algorithm component is responsible for carrying out all computations.
In order to function properly Data Source component as well as all configuration variables (like mutation coefficient etc.) has to be injected by Spring.

\subsection{Aggregating Node}

The sole purpose of Aggregating Node(AG) is to gather results from Computing Nodes(CN), choose the best non-dominated solution and write the results to file. 
Based on this file all charts are created and comparison of different algorithms is possible.
Communication between CNs and AG is provided by a single JMS queue (all CNs send results to one specific queue, AG consumes its content).


\subsection{Multi-agent system architecture}
\label{multi-agent}

%\clearpage
\begin{figure}[H]
  \begin{center}
    \includegraphics[scale=.4]{agent_framework.png}
  \end{center}
  \caption{Deployment diagram of two Computing Nodes and Aggregation Node (in real situations more Computing Nodes are present)}
\end{figure}

Data Source as well as Computing Algorithm are created and injected to Computing Node(CN) by Spring. 
CNs send results of computations to Aggregating Node by JMS. 
Apart from that, JMS is used to provide migration capability to each CN.

\subsection{Technologies used}

\begin{description}
  \item [R]
      Trend following algorithm has been implemented as an R script, historical data preprocessing.
  \item [Apache ActiveMQ]
      JMS implementation, provides communication between Computing Nodes and Aggregating Agent (\ref{multi-agent})
  \item [Java]
      Almost all algorithms are implemented in Java, Computing Nodes as well as Aggregating Node are in fact jar files 
  \item [Spring Framework]
      Inversion of Control container (configuration of application components and lifecycle management of Java objects), Messaging (simplifies the use of the JMS API) modules used.
  \item [Apache Maven]
      Used primarly for build automation.
  \item [JUnit]
      JUnit tests cover the most crucial functions of implemented algorithms.
  \item [git]
      Source Code Management tool.
  \item [bash scripts]
      Used for conveniently setting up and running test 
\end{description}

 